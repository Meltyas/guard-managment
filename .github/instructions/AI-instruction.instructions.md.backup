---
applyTo: '**'
---

# AI Assistant Context: Guard Management Module

## Project Overview

**Guard Management** is a Foundry VTT V13 module designed for the **Foundryborne system (Daggerheart)** to manage guard operations in campaigns. The module handles comprehensive guard management including statistics, patrols, resources, reputation, and temporary effects with full synchronization between GM and Players.

## Key Project Information

### Technologies

- **TypeScript**: Type-safe JavaScript development
- **Vite**: Fast build tool and development server
- **Vitest**: Fast unit testing framework
- **Foundry VTT V13**: Target platform
- **Node.js 20.11.0**: Required version (managed via nvm)

### Core Architecture

```
Guard Organization (base stats + resources + reputation)
  ├── Resources (organizational level)
  ├── Reputation (organizational level)
  ├── Guard Modifiers (affect entire organization)
  └── Patrols (derive from Guard organization stats)
      ├── Patrol Effects (specific to patrol)
      ├── Custom Modifiers (patrol-specific adjustments)
      └── Leader (references Actors)

GM Storage
  ↓ (templates for)
All Effect Types + Resources + Reputation + Modifiers
```

### Primary Entities

1. **Guard Organization**: Complete guard organization with 4 base stats (Robustismo, Analítica, Subterfugio, Elocuencia)
2. **Patrols**: Operational units (1-12 members + leader) with derived stats
3. **Resources**: Tracked materials and supplies
4. **Reputation**: 7-tier relationship system with factions
5. **Effects**: Temporary modifiers (organizational or patrol-specific)
6. **GM Storage**: Centralized template management

### Development Workflow

**Prerequisites**:

```bash
# Always use correct Node.js version
nvm use 20.11.0

# Development options
npm run dev          # Hot reload development
npm run build:watch  # Auto-rebuild for Foundry
npm run test:watch   # Tests in watch mode
```

Task Management Rules

Tasks must be clear, specific, and actionable—avoid ambiguity.

Every task must be assigned a responsible agent, explicitly tagged.

Complex tasks must be broken into atomic, trackable subtasks.

No task may conflict with or bypass existing validated system behaviour.

Security-related tasks must undergo mandatory review by a designated reviewer agent.

Agents must update task status and outcomes in the shared task file.

Dependencies between tasks must be explicitly declared.

Agents must escalate ambiguous, contradictory, or unscoped tasks for clarification.

⸻

Security Compliance Guidelines

Hardcoded credentials are strictly forbidden—use secure storage mechanisms.

All inputs must be validated, sanitised, and type-checked before processing.

Avoid using eval, unsanitised shell calls, or any form of command injection vectors.

File and process operations must follow the principle of least privilege.

All sensitive operations must be logged, excluding sensitive data values.

Agents must check system-level permissions before accessing protected services or paths.

⸻

Process Execution Requirements

Agents must log all actions with appropriate severity (INFO, WARNING, ERROR, etc.).

Any failed task must include a clear, human-readable error report.

Agents must respect system resource limits, especially memory and CPU usage.

Long-running tasks must expose progress indicators or checkpoints.

Retry logic must include exponential backoff and failure limits.

⸻

Core Operational Principles

Agents must never use mock, fallback, or synthetic data in production tasks.

Error handling logic must be designed using test-first principles.

Agents must always act based on verifiable evidence, not assumptions.

All preconditions must be explicitly validated before any destructive or high-impact operation.

All decisions must be traceable to logs, data, or configuration files.

⸻

Design Philosophy Principles

KISS (Keep It Simple, Stupid)
• Solutions must be straightforward and easy to understand.
• Avoid over-engineering or unnecessary abstraction.
• Prioritise code readability and maintainability.

YAGNI (You Aren’t Gonna Need It)
• Do not add speculative features or future-proofing unless explicitly required.
• Focus only on immediate requirements and deliverables.
• Minimise code bloat and long-term technical debt.

SOLID Principles

Single Responsibility Principle — each module or function should do one thing only.

Open-Closed Principle — software entities should be open for extension but closed for modification.

Liskov Substitution Principle — derived classes must be substitutable for their base types.

Interface Segregation Principle — prefer many specific interfaces over one general-purpose interface.

Dependency Inversion Principle — depend on abstractions, not concrete implementations.

⸻

System Extension Guidelines

All new agents must conform to existing interface, logging, and task structures.

Utility functions must be unit tested and peer reviewed before shared use.

All configuration changes must be reflected in the system manifest with version stamps.

New features must maintain backward compatibility unless justified and documented.

All changes must include a performance impact assessment.

⸻

Quality Assurance Procedures

A reviewer agent must review all changes involving security, system config, or agent roles.

Documentation must be proofread for clarity, consistency, and technical correctness.

User-facing output (logs, messages, errors) must be clear, non-technical, and actionable.

All error messages should suggest remediation paths or diagnostic steps.

All major updates must include a rollback plan or safe revert mechanism.

1. Obligar análisis comparativo completo
   Agregar: "Cuando implementes un sistema siguiendo un patrón existente, SIEMPRE haz primero una auditoría completa línea por línea del sistema de referencia. Lista TODAS las funcionalidades encontradas antes de empezar a implementar."

2. Checklist obligatorio
   Agregar: \*"Para cada implementación de patrón, crea y verifica este checklist:

✅ Templates y HTML
✅ Event handlers
✅ Drag & Drop functionality
✅ Dialog integration
✅ CSS styling
✅ Manager methods (CRUD)
✅ Warehouse integration
✅ Error handling
✅ Notifications
✅ Chat integration
✅ Focus management
✅ Validation"\* 3. Análisis de archivos relacionados

"Antes de dar por completada una implementación, busca TODOS los archivos que contengan el nombre del sistema de referencia y analiza qué funcionalidades implementan que podrían faltar en el nuevo sistema y asegurate que tiene contenido y tienen cosas dentro que funcionan, no asumas sin verificar."

4. Declaración de completitud
   Agregar: "Al finalizar cualquier implementación basada en un patrón, declara explícitamente: 'Esta implementación está COMPLETA y tiene paridad funcional 1:1 con [sistema de referencia]' solo después de verificar cada punto del checklist."

### TDD Implementation Strategy

**Test-First Development Approach**:

1. **Red**: Write failing tests for functionality
2. **Green**: Implement minimal working code
3. **Refactor**: Optimize and clean up

**Testing Priorities**:

- Unit Tests: CRUD operations, stat calculations, validation
- Integration Tests: Entity relationships, sync operations

### Synchronization Strategy

**Anti-Death Spiral Design**:

- All users should be able to edit all entities
- Version tracking for all entities
- Conflict detection and resolution
- Permission-based access (GM vs Player)
- Real-time updates with DialogV2

**Conflict Resolution Priorities**:

1. GM Override: GM changes take precedence
2. Timestamp: Most recent change wins
3. Manual Resolution: DialogV2 intervention for complex conflicts

### Key Implementation Notes

**Entity Relationships**: Guard Organization → Resources/Reputation → Patrols → Effects
**Stat Calculation Flow**: Guard Base → Organization Modifiers → Patrol Derivation → Custom Modifiers → Effects → Final Stats
**Permission Matrix**: GM has full CRUD, Players have read-all + limited modify
**Dialog Architecture**: Independent dialogs per entity type, all use DialogV2.query

### Development Phases

1. **Foundation**: Basic entity models, CRUD operations, simple sync
2. **Business Logic**: Stat calculations, effect application, validation
3. **Advanced Sync**: Conflict resolution, permissions, real-time updates
4. **GM Tools**: Storage management, batch operations, templates
5. **Polish**: Enhanced UI, performance, error handling

## AI Assistant Guidelines

When working on this project:

1. **Entity Hierarchy**: Always maintain Guard Organization → Patrols relationship
2. **Permission Awareness**: Respect GM vs Player access throughout
3. **TDD Discipline**: Write tests first for all functionality
4. **DialogV2 Focus**: Use DialogV2.query for all user interactions
5. **Performance**: Cache derived calculations, batch sync updates
6. **Spanish/English**: Support Daggerheart terminology in both languages
7. **Drag & Drop**: Implement extensive drag & drop for intuitive UX

## Current Project State

- **Foundation Phase**: Core CRUD operations and basic sync implemented
- **UI**: DialogV2-based interface with tab structure planned

## Debug and Testing

**Common Debug Scenarios**:

- Never create a debug tool javascript, we will use the UI
- Test guard CRUD operations
- Simulate sync conflicts
- Test permission boundaries
- Validate stat calculations

---

**Note**: This module is primarily for testing synchronization patterns in Foundry VTT. Focus on clear, well-tested code that demonstrates different sync scenarios rather than production features.
